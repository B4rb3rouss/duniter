#!/usr/bin/env node
var server   = require('../app/lib/server');
var jpgp     = require('../app/lib/jpgp');
var wizard   = require('../app/lib/wizard');
var fs       = require('fs');
var os       = require('os');
var async    = require('async');
var _        = require('underscore');
var program  = require('commander');
var mongoose = require('mongoose');
var moment   = require('moment');
var inquirer = require('inquirer');
var openpgp  = require('openpgp');
var logger   = require('../app/lib/logger')('ucoind');
var service  = require('../app/service');

function keys (val) {
  return val.split(',');
}

program
  .version('0.5.6')
  .usage('<command> [options]')
  .option('-p, --port <port>', 'Port to listen for requests', parseInt)
  .option('-c, --currency <name>', 'Name of the currency managed by this node.')
  .option('--mhost <host>', 'MongoDB host.')
  .option('--mport <port>', 'MongoDB port.')
  .option('-d, --mdb <name>', 'MongoDB database name (defaults to "ucoin_default").')
  .option('--pgpkey <keyPath>', 'Path to the private key used for signing HTTP responses.')
  .option('--pgppasswd <password>', 'Password for the key provided with --httpgp-key option.')
  .option('--ipv4 <address>', 'IPV4 interface to listen for requests')
  .option('--ipv6 <address>', 'IPV6 interface to listen for requests')
  .option('--remoteh <host>', 'Remote interface others may use to contact this node')
  .option('--remote4 <host>', 'Remote interface for IPv4 access')
  .option('--remote6 <host>', 'Remote interface for IPv6 access')
  .option('--remotep <port>', 'Remote port others may use to contact this node')
  .option('--kmanagement <ALL|KEYS>', 'Define key management policy')
  .option('--kaccept <ALL|KEYS>', 'Define key acceptance policy')
  .option('--amdaemon <ON|OFF>', 'ucoin is launched with a specific daemon helping to get other peers\' votes')
  .option('--amstart <timestamp>', 'First amendment generated date', parseMoment)
  .option('--amfreq <timestamp>', 'Amendments frequency, in seconds', parseInt)
  .option('--udfreq <timestamp>', 'Universal Dividend frequency, in seconds', parseInt)
  .option('--ud0 <integer>', 'First Universal Dividend value (a.k.a \'UD0\')', parseInt)
  .option('--udpercent <float>', 'Percent of monetary mass growth per UD', parseFloat)
  .option('--consensus <float>', 'Percent of voters required to accept an amendment', parseFloat)
  .option('--msvalidity <timestamp>', 'Duration of a valid membership, in seconds', parseInt)
  .option('--vtvalidity <timestamp>', 'Duration of a valid voter, in seconds', parseInt)
  .option('--openpgpjs', 'Prefer using embedded Openpgpjs implementation for signing requests')
  ;

program
  .command('wizard [step]')
  .description('Launch the configuration Wizard')
  .action(connect(function (step, conf) {
    var wiz = wizard();
    var task = {
      'currency': wiz.configCurrency,
      'openpgp': wiz.configOpenpgp,
      'network': wiz.configNetwork,
      'key': wiz.configKey,
      'autovote': wiz.configAutovote
    };
    var wizDo = task[step] || wiz.configAll;
    async.waterfall([
      function (next){
        wizDo(conf, next);
      },
      function (next){
        conf.save(function (err) {
          !err && logger.debug("Configuration saved.");
          next(err);
        });
      },
      function (next) {
        server.checkConf(conf, function (err) {
          logger.warn(err);
        });
        next();
      }
    ], function (err, result) {
      err && logger.error(err);
      server.database.disconnect();
      process.exit();
    });
  }));

program
  .command('sync [host] [port]')
  .description('Tries to synchronise data with remote uCoin node')
  .action(connect(function (host, port, conf) {

    // Disable daemon
    conf.sync.AMDaemon = "OFF";

    async.series([
      function (next){
        // Synchronize
        var Synchroniser = require('../app/lib/sync');
        var remote = new Synchroniser(server, host, port, false, conf);
        remote.sync(next);
      },
    ], function (err) {
      if(err){
        logger.error('Error during sync:', err);
      }
      server.database.disconnect();
      process.exit();
    });
  }));

program
  .command('allow-key [key]')
  .description('Add given key to authorized keys of this node')
  .action(connect(function (key, conf) {
    key = key || "";
    key = key.toUpperCase();
    async.waterfall([
      function (next) {
        if (!key.isSha1()) {
          next("Key must match a SHA-1 hash");
          return;
        }
        next();
      },
      function (next){
        service.Key.setKnown(key, next);
      }
    ], function (err, result) {
      if(err){
        logger.error('Error: %s', err);
        server.database.disconnect();
        return;
      }
      logger.debug("Key %s is now allowed to be stored" , key);
      server.database.disconnect();
      process.exit();
    });
  }));

program
  .command('manage-key [key]')
  .description('Add given key to stack of managed keys of this node')
  .action(connect(function (key, conf) {
    handleKey(conf, key, true, 'Key %s is now managed');
  }));

program
  .command('forget-key [key]')
  .description('Remove given key of the managed keys\' stack of this node')
  .action(connect(function (key, conf) {
    handleKey(conf, key, false, 'Key %s no more managed from now');
  }));

function handleKey (conf, key, isManaged, message) {
  key = key || "";
  key = key.toUpperCase();
  async.waterfall([
    function (next){
      service.Key.handleKey(key, isManaged, next);
    }
  ], function (err, result) {
    if(err){
      logger.error('Error: %s', err);
      server.database.disconnect();
      return;
    }
    logger.debug(message , key);
    server.database.disconnect();
    process.exit();
  });
}

program
  .command('check-config')
  .description('Checks the node\'s configuration')
  .action(connect(function (conf) {
    server.checkConf(conf, function (err) {
      logger.warn(err);
    });
    server.database.disconnect();
    process.exit();
    return;
  }));

program
  .command('config')
  .description('Register configuration in database')
  .action(connect(function (conf) {
    overrideConf(conf).save(function (err) {
      if(err){
        logger.error("Configuration could not be saved: " + err);
      }
      else{
        logger.debug("Configuration saved.");
      }
      server.database.disconnect();
      process.exit();
      return;
    });
  }));

program
  .command('reset [config|data]')
  .description('Reset configuration or data in database')
  .action(connect(function (type, conf) {
    if(!~['config', 'data'].indexOf(type)){
      logger.error('Bad command: usage `reset config` or `reset data`');
      server.database.disconnect();
      return;
    }
    if(type == 'data'){
      server.database.reset(function (err) {
        if(err)
          logger.error(err);
        server.database.disconnect();
        process.exit();
      });
    }
    if(type == 'config'){
      server.database.resetConf(function (err) {
        if(err)
          logger.error(err);
        server.database.disconnect();
        process.exit();
      });
    }
  }));

program
  .command('start')
  .description('Start uCoin server using given --currency')
  .action(connect(function (conf) {

    // Launching server
    server.express.app(conf, function (err, app) {

      if(err){
        console.error(err);
        server.database.disconnect();
        process.exit();
        return;
      }
      logger.debug('Server ready!');
    });
  }));

var config = {};

function overrideConf(conf) {

  // Ensure is not null and have good structure
  var Configuration = mongoose.model('Configuration');
  conf = conf || new Configuration();

  cli = {
    currency: program.currency,
    server: {
      port: program.port,
      ipv4address: program.ipv4,
      ipv6address: program.ipv6,
      pgp: {
        key: program.pgpkey,
        password: program.pgppasswd
      },
      remote: {
        host: program.remoteh,
        ipv4: program.remote4,
        ipv6: program.remote6,
        port: program.remotep
      },
      openpgpjs: program.openpgpjs
    },
    db: {
      host: program.mhost,
      port: program.mport,
      database: program.mdb,
    },
    policy: {
      keys: program.kmanagement,
      pubkeys: program.kaccept
    },
    sync: {
      AMDaemon: program.amdaemon,
      AMStart: program.amstart,
      AMFreq: program.amfreq,
      UDFreq: program.udfreq,
      UD0: program.ud0,
      UDPercent: program.udpercent,
      Consensus: program.consensus,
      MSExpires: program.msvalidity,
      VTExpires: program.vtvalidity
    }
  };

  // Update conf
  if(cli.server.pgp.key) cli.server.pgp.key = fs.readFileSync(cli.server.pgp.key, 'utf8');
  conf.currency    = cli.currency || conf.currency;
  conf.openpgpjs   = cli.server.openpgpjs != undefined ? cli.server.openpgpjs : conf.openpgpjs;
  conf.ipv4        = cli.server.ipv4address || conf.ipv4;
  conf.ipv6        = cli.server.ipv6address || conf.ipv6;
  conf.port        = cli.server.port || conf.port;
  conf.pgpkey      = cli.server.pgp.key || conf.pgpkey;
  conf.pgppasswd   = cli.server.pgp.password != undefined ? cli.server.pgp.password : conf.pgppasswd;
  conf.remotehost  = cli.server.remote.host != undefined ? cli.server.remote.host : conf.remotehost;
  conf.remoteipv4  = cli.server.remote.ipv4 != undefined ? cli.server.remote.ipv4 : conf.remoteipv4;
  conf.remoteipv6  = cli.server.remote.ipv6 != undefined ? cli.server.remote.ipv6 : conf.remoteipv6;
  conf.remoteport  = cli.server.remote.port != undefined ? cli.server.remote.port : conf.remoteport;
  conf.kmanagement = cli.policy.keys || conf.kmanagement;
  conf.kaccept     = cli.policy.pubkeys || conf.kaccept;
  conf.sync        = {
    AMDaemon: cli.sync.AMDaemon || conf.sync.AMDaemon,
    AMStart: cli.sync.AMStart || conf.sync.AMStart,
    AMFreq: cli.sync.AMFreq || conf.sync.AMFreq,
    UDFreq: cli.sync.UDFreq || conf.sync.UDFreq,
    UD0: cli.sync.UD0 || conf.sync.UD0,
    UDPercent: cli.sync.UDPercent || conf.sync.UDPercent,
    Consensus: cli.sync.Consensus || conf.sync.Consensus,
    MSExpires: cli.sync.MSExpires || conf.sync.MSExpires,
    VTExpires: cli.sync.VTExpires || conf.sync.VTExpires
  };

  // Specific internal settings
  conf.createNext = true;
  return conf;
}

function connect(callback) {
  return function () {
    var cbArgs = arguments;
    var dbName = program.mdb || "ucoin_default";

    // Connecting to DB
    server.database.connect(dbName, program.mhost, program.mport, function (err, conf) {

      if(err){
        logger.debug("Error connecting to DB: " + err);
        server.database.disconnect();
        return;
      }
      cbArgs.length--;
      cbArgs[cbArgs.length++] = overrideConf(conf);
      callback.apply(this, cbArgs);
    });
  };
}

function parseMoment (d) {
  if (d.toLowerCase() == 'now') {
    return parseInt(moment().format("X"));
  } else if (d.match(/\d{2}-\d{2}-\d{4}/)) {
    return parseInt(moment(d, "DD-MM-YYYY").format("X"));
  } else {
    return parseInt(d);
  }
}

program.parse(process.argv);
