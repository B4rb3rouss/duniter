#!/usr/bin/env node
var fs          = require('fs');
var os          = require('os');
var async       = require('async');
var _           = require('underscore');
var program     = require('commander');
var mongoose    = require('mongoose');
var moment      = require('moment');
var inquirer    = require('inquirer');
var openpgp     = require('openpgp');
var jpgp        = require('../app/lib/jpgp');
var wizard      = require('../app/lib/wizard');
var router      = require('../app/lib/streams/router');
var multicaster = require('../app/lib/streams/multicaster');
var logger      = require('../app/lib/logger')('ucoind');
var signature   = require('../app/lib/signature');
var ucoin       = require('./..');

function keys (val) {
  return val.split(',');
}

// Constants
var LISTEN_HTTP = true;
var DO_NOT_LISTEN_HTTP = false;

program
  .version('0.6.1')
  .usage('<command> [options]')
  .option('-p, --port <port>', 'Port to listen for requests', parseInt)
  .option('-c, --currency <name>', 'Name of the currency managed by this node.')
  .option('--mhost <host>', 'MongoDB host.')
  .option('--mport <port>', 'MongoDB port.')
  .option('-d, --mdb <name>', 'MongoDB database name (defaults to "ucoin_default").')
  .option('--pgpkey <keyPath>', 'Path to the private key used for signing HTTP responses.')
  .option('--pgppasswd <password>', 'Password for the key provided with --httpgp-key option.')
  .option('--ipv4 <address>', 'IPV4 interface to listen for requests')
  .option('--ipv6 <address>', 'IPV6 interface to listen for requests')
  .option('--remoteh <host>', 'Remote interface others may use to contact this node')
  .option('--remote4 <host>', 'Remote interface for IPv4 access')
  .option('--remote6 <host>', 'Remote interface for IPv6 access')
  .option('--remotep <port>', 'Remote port others may use to contact this node')
  .option('--kmanagement <ALL|KEYS>', 'Define key management policy')
  .option('--kaccept <ALL|KEYS>', 'Define key acceptance policy')
  .option('--openpgpjs', 'Prefer using embedded Openpgpjs implementation for signing requests')
  ;

program
  .command('send-pubkey [host] [port]')
  .description('Send self pubkey to given node')
  .action(function (host, port) {
    // Only show message "Saved"
    require('log4js').configure({
      "appenders": [{
        category: "ucoind",
        type: "console"
      }]
    });
    service(DO_NOT_LISTEN_HTTP, ucoin.createPeerServer, function (server, conf) {
      // Only show message "Saved"
      require('log4js').configure({
        "appenders": [{
          category: "multicaster",
          type: "console"
        }]
      });
      async.waterfall([
        function (next){
          server.on('peerInited', next);
        },
        function (next){
          server.PublicKeyService.getTheOne(server.PeeringService.cert.fingerprint, next);
        },
        function (pubkey, next){
          var Peer = server.conn.model('Peer');
          var peer = new Peer({
            endpoints: [['BASIC_MERKLED_API', host, port].join(' ')]
          });
          multicaster().sendPubkey(peer, pubkey, next);
        },
      ], function (err, result) {
        if (err) logger.error(err);
        server.disconnect();
        process.exit();
      });
    })(null);
  });

program
  .command('wizard [step]')
  .description('Launch the configuration Wizard')
  .action(function (step) {
    // Only show message "Saved"
    require('log4js').configure({
      "appenders": [{
        category: "ucoind",
        type: "console"
      }]
    });
    connect(function (step, server, conf) {
      var wiz = wizard(server);
      var task = {
        'currency': wiz.configCurrency,
        'openpgp': wiz.configOpenpgp,
        'network': wiz.configNetwork,
        'key': wiz.configKey
      };
      var wizDo = task[step] || wiz.configAll;
      async.waterfall([
        function (next){
          wizDo(conf, next);
        },
        function (next){
          conf.save(function (err) {
            !err && logger.debug("Configuration saved.");
            next(err);
          });
        },
        function (next) {
          // Check config
          service(DO_NOT_LISTEN_HTTP, ucoin.createPeerServer, function (key, server, conf) {
            next();
          })(null, null);
        }
      ], function (err, result) {
        err && logger.error(err);
        server.disconnect();
        process.exit();
      });
    })(step, null);
  });

program
  .command('sync [host] [port]')
  .description('Tries to synchronise data with remote uCoin node')
  .action(service(DO_NOT_LISTEN_HTTP, ucoin.createRegistryServer, function (host, port, server, conf) {

    // Disable daemon
    conf.sync.AMDaemon = "OFF";
    conf.createNext = false;

    async.series([
      function (next){
        // Synchronize
        var Synchroniser = require('../app/lib/sync');
        var remote = new Synchroniser(server, host, port, false, conf);
        remote.sync(next);
      },
    ], function (err) {
      if(err){
        logger.error('Error during sync:', err);
      }
      server.disconnect();
      process.exit();
    });
  }));

program
  .command('allow-key [key]')
  .description('Add given key to authorized keys of this node')
  .action(service(DO_NOT_LISTEN_HTTP, ucoin.createHDCServer, function (key, server, conf) {
    key = key || "";
    key = key.toUpperCase();
    async.waterfall([
      function (next) {
        if (!key.isSha1()) {
          next("Key must match a SHA-1 hash");
          return;
        }
        next();
      },
      function (next){
        server.KeyService.setKnown(key, next);
      }
    ], function (err, result) {
      if(err){
        logger.error('Error: %s', err);
        server.disconnect();
        process.exit();
        return;
      }
      logger.debug("Key %s is now allowed to be stored" , key);
      server.disconnect();
      process.exit();
    });
  }));

program
  .command('manage-key [key]')
  .description('Add given key to stack of managed keys of this node')
  .action(service(DO_NOT_LISTEN_HTTP, ucoin.createHDCServer, function (key, server, conf) {
    handleKey(server, key, true, 'Key %s is now managed');
  }));

program
  .command('forget-key [key]')
  .description('Remove given key of the managed keys\' stack of this node')
  .action(service(DO_NOT_LISTEN_HTTP, ucoin.createHDCServer, function (key, server, conf) {
    handleKey(server, key, false, 'Key %s no more managed from now');
  }));

function handleKey (server, key, isManaged, message) {
  key = key || "";
  key = key.toUpperCase();
  async.waterfall([
    function (next){
      server.initServices(next);
    },
    function (next){
      server.KeyService.handleKey(key, isManaged, next);
    }
  ], function (err, result) {
    if(err){
      logger.error('Error: %s', err);
      server.disconnect();
      return;
    }
    logger.debug(message , key);
    server.disconnect();
    process.exit();
  });
}

program
  .command('gen-root [host] [port] [difficulty]')
  .description('Tries to generate the root keyblock of the keychain using already received keys & memberships')
  .action(service(DO_NOT_LISTEN_HTTP, ucoin.createWOTServer, function (host, port, difficulty, server, conf) {
    var Membership = server.conn.model('Membership');
    var KeychainService = server.KeychainService;
    async.waterfall([
      function (next){
        if (!host || !port) {
          next('usage: gen-root [host] [port]');
          return;
        }
        Membership.find({ eligible: true }, next);
      },
      function (mss, next){
        if (mss.length == 0) {
          next('No membership was received, no changes to add.');
          return;
        }
        var uids = [];
        mss.forEach(function(ms){
          uids.push(ms.userid);
        });
        if (mss.length > 0) {
          inquirer.prompt([{
            type: "checkbox",
            name: "uids",
            message: "Initial members of the Web of Trust",
            choices: uids,
            default: uids[0]
          }], function (answers) {
            next(null, answers.uids);
          });
        } else {
          logger.info('No membership were found, trying to write an empty block');
          next(null, []);
        }
      },
      function (uids, next){
        KeychainService.generateRoot(uids, next);
      },
      function (root, next){
        var wiz = wizard(server);
        async.waterfall([
          function (next){
            wiz.configOpenpgp(conf, next);
          },
          function (next){
            wiz.configKey(conf, next);
          },
          function (next){
            signature(conf.pgpkey, conf.pgppasswd, conf.openpgpjs, next);
          },
          function (sigFunc, next){
            proveAndSend(server, root, sigFunc, difficulty, host, port, next);
          },
        ], next);
      },
    ], function (err) {
      if (err) {
        logger.error(err);
      }
      server.disconnect();
      process.exit();
    });
  }));

program
  .command('gen-empty-next [host] [port] [difficulty]')
  .description('Tries to generate the next keyblock of the keychain without any keychange')
  .action(service(DO_NOT_LISTEN_HTTP, ucoin.createWOTServer, function (host, port, difficulty, server, conf) {
    var KeychainService = server.KeychainService;
    async.waterfall([
      function (next){
        KeychainService.generateEmptyNext(next);
      },
      function (block, next){
        var wiz = wizard(server);
        async.waterfall([
          function (next){
            wiz.configOpenpgp(conf, next);
          },
          function (next){
            wiz.configKey(conf, next);
          },
          function (next){
            signature(conf.pgpkey, conf.pgppasswd, conf.openpgpjs, next);
          },
          function (sigFunc, next){
            proveAndSend(server, block, sigFunc, difficulty, host, port, next);
          },
        ], next);
      },
    ], function (err) {
      if (err) {
        logger.error(err);
      }
      server.disconnect();
      process.exit();
    });
  }));

function proveAndSend (server, block, sigFunc, difficulty, host, port, done) {
  var KeychainService = server.KeychainService;
  async.waterfall([
    function (next){
      KeychainService.prove(block, sigFunc, difficulty, next);
    },
    function (block, next){
      var Peer = server.conn.model('Peer');
      var peer = new Peer({
        endpoints: [['BASIC_MERKLED_API', host, port].join(' ')]
      });
      // console.log(block.getRaw());
      // console.log(block.signature);
      multicaster().sendKeyblock(peer, block, next);
    },
  ], done);
}

program
  .command('check-config')
  .description('Checks the node\'s configuration')
  .action(service(function (server, conf) {
    server.checkConfig(function (err) {
      if (err)
        logger.warn(err);
      else
        logger.warn('Configuration seems correct.');
      server.disconnect();
      process.exit();
    });
    return;
  }));

program
  .command('config')
  .description('Register configuration in database')
  .action(service(false, function (server, conf) {
    conf.save(function (err) {
      if(err){
        logger.error("Configuration could not be saved: " + err);
      }
      else{
        logger.debug("Configuration saved.");
      }
      server.disconnect();
      process.exit();
      return;
    });
  }));

program
  .command('reset [config|data]')
  .description('Reset configuration or data in database')
  .action(service(function (type, server, conf) {
    if(!~['config', 'data'].indexOf(type)){
      logger.error('Bad command: usage `reset config` or `reset data`');
      server.disconnect();
      return;
    }
    if(type == 'data'){
      server.reset(function (err) {
        if(err)
          logger.error(err);
        else
          logger.warn('Data successfuly reseted.');
        server.disconnect();
        process.exit();
      });
    }
    if(type == 'config'){
      server.resetConf(function (err) {
        if(err)
          logger.error(err);
        else
          logger.warn('Configuration successfuly reseted.');
        server.disconnect();
        process.exit();
      });
    }
  }));

program
  .command('start')
  .description('Start uCoin server using given --currency')
  .action(service(LISTEN_HTTP, ucoin.createWOTServer, function (server, conf) {

    // server
    //   .pipe(router(server.PeeringService.cert.fingerprint, server.conn))
    //   .pipe(multicaster());

    // Launching server
    server.on('BMALoaded', function (err, app) {
      if(err){
        console.error(err);
        this.disconnect();
        process.exit();
        return;
      }
      logger.debug('Server ready!');
    });
  }));

function overrideConf(conf) {

  conf.sync = conf.sync || {};
  var cli = {
    currency: program.currency,
    server: {
      port: program.port,
      ipv4address: program.ipv4,
      ipv6address: program.ipv6,
      pgp: {
        key: program.pgpkey,
        password: program.pgppasswd
      },
      remote: {
        host: program.remoteh,
        ipv4: program.remote4,
        ipv6: program.remote6,
        port: program.remotep
      },
      openpgpjs: program.openpgpjs
    },
    db: {
      host: program.mhost,
      port: program.mport,
      database: program.mdb,
    },
    policy: {
      keys: program.kmanagement,
      pubkeys: program.kaccept
    }
  };

  if(cli.server.pgp.key) cli.server.pgp.key = fs.readFileSync(cli.server.pgp.key, 'utf8');

  // Update conf
  if (cli.currency)                         conf.currency       = cli.currency;
  if (cli.server.ipv4address)               conf.ipv4           = cli.server.ipv4address;
  if (cli.server.ipv6address)               conf.ipv6           = cli.server.ipv6address;
  if (cli.server.port)                      conf.port           = cli.server.port;
  if (cli.server.openpgpjs != undefined)    conf.openpgpjs      = cli.server.openpgpjs;
  if (cli.server.pgp.key)                   conf.pgpkey         = cli.server.pgp.key;
  if (cli.server.pgp.password != undefined) conf.pgppasswd      = cli.server.pgp.password;
  if (cli.server.remote.host != undefined)  conf.remotehost     = cli.server.remote.host;
  if (cli.server.remote.ipv4 != undefined)  conf.remoteipv4     = cli.server.remote.ipv4;
  if (cli.server.remote.ipv6 != undefined)  conf.remoteipv6     = cli.server.remote.ipv6;
  if (cli.server.remote.port != undefined)  conf.remoteport     = cli.server.remote.port;
  if (cli.policy.keys)                      conf.kmanagement    = cli.policy.keys;
  if (cli.policy.pubkeys)                   conf.kaccept        = cli.policy.pubkeys;

  // Specific internal settings
  conf.createNext = true;
  return conf;
}

function connect(callback) {
  return function () {
    var cbArgs = arguments;
    var dbName = program.mdb || "ucoin_default";

    var server = ucoin.connect({ name: dbName, host: program.mhost, port: program.mport }, overrideConf({}));

    // Connecting to DB
    server.on('connected', function (err) {

      if(err){
        logger.warn(err);
        server.disconnect();
        process.exit(1);
        return;
      }

      cbArgs.length--;
      cbArgs[cbArgs.length++] = server;
      cbArgs[cbArgs.length++] = server.conf;
      callback.apply(this, cbArgs);
    });
  };
}

function service(listenHTTP, serverFactory, callback) {
  if (arguments.length == 1) {
    callback = listenHTTP;
    listenHTTP = false;
    serverFactory = ucoin.createWOTServer;
  } else if (arguments.length == 2) {
    callback = serverFactory;
    serverFactory = ucoin.createHDCServer;
  }
  return function () {
    var cbArgs = arguments;
    var dbName = program.mdb || "ucoin_default";

    var server = serverFactory({ name: dbName, host: program.mhost, port: program.mport, listenBMA: listenHTTP }, overrideConf({}));

    // Connecting to DB
    server.on('services', function (err) {

      if(err){
        logger.warn(err);
        server.disconnect();
        process.exit(1);
        return;
      }

      cbArgs.length--;
      cbArgs[cbArgs.length++] = server;
      cbArgs[cbArgs.length++] = server.conf;
      callback.apply(this, cbArgs);
    });
  };
}

function parseMoment (d) {
  if (d.toLowerCase() == 'now') {
    return parseInt(moment().format("X"));
  } else if (d.match(/^\d{2}-\d{2}-\d{4}$/)) {
    return parseInt(moment(d, "DD-MM-YYYY").format("X"));
  } else if (d.match(/^\d{2}-\d{2}-\d{4} \d{2}:\d{2}:\d{2}$/)) {
    return parseInt(moment(d, "DD-MM-YYYY hh:mm:ss").format("X"));
  } else {
    return parseInt(d);
  }
}

function splitColon (str) {
  return str.split(':');
}

program.parse(process.argv);
